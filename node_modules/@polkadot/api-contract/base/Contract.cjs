"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = exports.ContractSubmittableResult = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _bn = _interopRequireDefault(require("bn.js"));

var _api = require("@polkadot/api");

var _util = require("@polkadot/util");

var _operators = require("@polkadot/x-rxjs/operators");

var _util2 = require("../util.cjs");

var _Base = require("./Base.cjs");

// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
// As per Rust, 5 * GAS_PER_SEC
const MAX_CALL_GAS = new _bn.default(5000000000000).subn(1);
const ERROR_NO_CALL = 'Your node does not expose the contracts.call RPC. This is most probably due to a runtime configuration.';
const l = (0, _util.logger)('Contract');

function createQuery(fn) {
  return (origin, options, ...params) => (0, _util2.isOptions)(options) ? fn(origin, options, params) : fn(origin, ...(0, _util2.extractOptions)(options, params));
}

function createTx(fn) {
  return (options, ...params) => (0, _util2.isOptions)(options) ? fn(options, params) : fn(...(0, _util2.extractOptions)(options, params));
}

function createWithId(fn, warn) {
  return (messageOrId, options, ...params) => {
    warn && l.warn(warn);
    return (0, _util2.isOptions)(options) ? fn(messageOrId, options, params) : fn(messageOrId, ...(0, _util2.extractOptions)(options, params));
  };
}

class ContractSubmittableResult extends _api.SubmittableResult {
  constructor(result, contractEvents) {
    super(result);
    this.contractEvents = void 0;
    this.contractEvents = contractEvents;
  }

} // map from a JSON result to current-style ContractExecResult


exports.ContractSubmittableResult = ContractSubmittableResult;

function mapExecResult(registry, json) {
  if (!Object.keys(json).some(key => ['error', 'success'].includes(key))) {
    return registry.createType('ContractExecResult', json);
  }

  const from = registry.createType('ContractExecResultTo260', json);

  if (from.isSuccess) {
    const s = from.asSuccess;
    return registry.createType('ContractExecResult', {
      gasConsumed: s.gasConsumed,
      result: {
        ok: {
          data: s.data,
          flags: s.flags
        }
      }
    });
  } // in the old format error has no additional information,
  // map it as-is with an "unknown" error


  return registry.createType('ContractExecResult', {
    result: {
      err: {
        other: 'unknown'
      }
    }
  });
}

var _query = (0, _classPrivateFieldLooseKey2.default)("query");

var _tx = (0, _classPrivateFieldLooseKey2.default)("tx");

var _getGas = (0, _classPrivateFieldLooseKey2.default)("getGas");

var _exec = (0, _classPrivateFieldLooseKey2.default)("exec");

var _read = (0, _classPrivateFieldLooseKey2.default)("read");

class Contract extends _Base.Base {
  /**
   * @description The on-chain address for this contract
   */

  /**
   * @deprecated
   * @description Deprecated. Use `.tx.<messageName>` to send a transaction.
   */

  /**
   * @deprecated
   * @description Deprecated. Use `.tx.<messageName>` to send a transaction.
   */
  constructor(api, abi, address, decorateMethod) {
    super(api, abi, decorateMethod);
    this.address = void 0;
    this.exec = void 0;
    this.read = void 0;
    Object.defineProperty(this, _query, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _getGas, {
      writable: true,
      value: (_gasLimit, isCall = false) => {
        const gasLimit = (0, _util.bnToBn)(_gasLimit);
        return gasLimit.lten(0) ? isCall ? MAX_CALL_GAS : (this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system.maximumBlockWeight).muln(64).divn(100) : gasLimit;
      }
    });
    Object.defineProperty(this, _exec, {
      writable: true,
      value: (messageOrId, {
        gasLimit = 0,
        value = 0
      }, params) => {
        return this.api.tx.contracts.call(this.address, value, (0, _classPrivateFieldLooseBase2.default)(this, _getGas)[_getGas](gasLimit), this.abi.findMessage(messageOrId).toU8a(params)).withResultTransform(result => // ContractEmitted is the current generation, ContractExecution is the previous generation
        new ContractSubmittableResult(result, (0, _util2.applyOnEvent)(result, ['ContractEmitted', 'ContractExecution'], records => records.map(({
          event: {
            data: [, data]
          }
        }) => {
          try {
            return this.abi.decodeEvent(data);
          } catch (error) {
            l.error(`Unable to decode contract event: ${error.message}`);
            return null;
          }
        }).filter(decoded => !!decoded))));
      }
    });
    Object.defineProperty(this, _read, {
      writable: true,
      value: (messageOrId, {
        gasLimit = 0,
        value = 0
      }, params) => {
        (0, _util.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
        const message = this.abi.findMessage(messageOrId);
        return {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          send: this._decorateMethod(origin => this.api.rx.rpc.contracts.call.json({
            dest: this.address,
            gasLimit: (0, _classPrivateFieldLooseBase2.default)(this, _getGas)[_getGas](gasLimit, true),
            inputData: message.toU8a(params),
            origin,
            value
          }).pipe((0, _operators.map)(json => {
            const {
              debugMessage,
              gasConsumed,
              result
            } = mapExecResult(this.registry, json.toJSON());
            return {
              debugMessage,
              gasConsumed,
              output: result.isOk && message.returnType ? (0, _util2.formatData)(this.registry, result.asOk.data, message.returnType) : null,
              result
            };
          })))
        };
      }
    });
    this.address = this.registry.createType('AccountId', address);
    this.exec = createWithId((0, _classPrivateFieldLooseBase2.default)(this, _exec)[_exec], '.exec is deprecated, use contract.tx.<messageName>(...) instead (where contract refers to this instance)');
    this.read = createWithId((0, _classPrivateFieldLooseBase2.default)(this, _read)[_read], '.read is deprecated, use contract.query.<messageName>(...) instead (where contract refers to this instance)');
    this.abi.messages.forEach(m => {
      const messageName = (0, _util.stringCamelCase)(m.identifier);

      if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName])) {
        (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName] = createTx((o, p) => (0, _classPrivateFieldLooseBase2.default)(this, _exec)[_exec](m, o, p));
      }

      if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _query)[_query][messageName])) {
        (0, _classPrivateFieldLooseBase2.default)(this, _query)[_query][messageName] = createQuery((f, o, p) => (0, _classPrivateFieldLooseBase2.default)(this, _read)[_read](m, o, p).send(f));
      }
    });
  }

  get hasRpcContractsCall() {
    var _this$api$rx$rpc$cont;

    return (0, _util.isFunction)((_this$api$rx$rpc$cont = this.api.rx.rpc.contracts) === null || _this$api$rx$rpc$cont === void 0 ? void 0 : _this$api$rx$rpc$cont.call);
  }

  get query() {
    (0, _util.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
    return (0, _classPrivateFieldLooseBase2.default)(this, _query)[_query];
  }

  get tx() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx];
  }

}

exports.Contract = Contract;